// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.7.0 <0.9.0;

contract ShPlonkVerifier {

    uint32 constant n = <%= 2**vk.power %>; // Domain size

    // Verification Key data
    // Omegas
<% for (let i = 0; i < Object.keys(ws).length; ++i) { -%>
    uint256 constant <%- Object.keys(ws)[i] %> = <%= ws[Object.keys(ws)[i]] %>;
<% } -%>
   
    // Verifier preprocessed input x·[1]_2
    uint256 constant X2x1 = <%= vk.X_2[0][0] %>;
    uint256 constant X2x2 = <%= vk.X_2[0][1] %>;
    uint256 constant X2y1 = <%= vk.X_2[1][0] %>;
    uint256 constant X2y2 = <%= vk.X_2[1][1] %>;

    // Scalar field size
    uint256 constant q    = 21888242871839275222246405745257275088548364400416034343698204186575808495617;
    // Base field size
    uint256 constant qf   = 21888242871839275222246405745257275088696311157297823662689037894645226208583;

<%  for(let i = 0; i < vk.f.length; ++i) { -%>
<%      if(vk.f[i].stages.length === 1 && vk.f[i].stages[0].stage === 0) {  -%>
    uint256 constant f<%- vk.f[i].index %>x = <%= vk[`f${vk.f[i].index}`][0] %>;
    uint256 constant f<%- vk.f[i].index %>y = <%= vk[`f${vk.f[i].index}`][1] %>;
<%      } -%>
<%  } -%>

    // [1]_1
    uint256 constant G1x  = 1;
    uint256 constant G1y  = 2;
    // [1]_2
    uint256 constant G2x1 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;
    uint256 constant G2x2 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;
    uint256 constant G2y1 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;
    uint256 constant G2y2 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;

    // Commits calldata
    // Byte offset of every parameter in the calldata
    // Polynomial commitments W and Wp
    uint16 constant pW = 4 + 0;
    uint16 constant pWp = 4 + 64;

    // Polynomial commitments fi
<%  let count = 128; -%>
<%  for(let i = 0; i < vk.f.length; ++i) { -%>
<%      if(vk.f[i].stages.length !== 1 || vk.f[i].stages[0].stage !== 0) { -%>
    uint16 constant pf<%- vk.f[i].index %> = 4 + <%- count %>;
<%      count += 64 -%>
<%      } -%>
<%  } -%>
    // Opening evaluations
<%  for(let i = 0; i < orderedEvals.length; ++i) { -%>
    uint16 constant pEval_<%- orderedEvals[i] %> = 4 + <%- count %>;
<% count += 32 -%>
<%  } -%>

    // Memory data
    // Challenges
    uint16 constant pY      = 0;
    uint16 constant pAlpha  = 32;

    // XiSeeds
<%  if(!xiSeed) { -%>
    uint16 constant pXiSeed = 64;
<% } -%>
<%  let memC = 96; -%>
<%  let degreesXi = [] -%>
<%  for (let i = 0; i < vk.f.length; ++i) { -%>
<%     if(!degreesXi.includes(vk.f[i].pols.length)) { -%>
<%          degreesXi.push(vk.f[i].pols.length); -%>
    uint16 constant pXiSeed_w<%- vk.f[i].pols.length %> = <%- memC %>;
<%      memC += 32; -%>
<% } -%>
<% } -%>

    // Roots
<%  let rootsNames = []; -%>
<%  let vkSorted = [...vk.f].sort((a,b) => a.pols.length - b.pols.length) -%>
<%  for(let i = 0; i < vkSorted.length; i++) { -%>
<%      for(let k = 0; k < vkSorted[i].openingPoints.length; k++) { -%>
<%  let wName = vkSorted[i].openingPoints[k] === 0 ? vkSorted[i].pols.length : `${vkSorted[i].pols.length}_${vkSorted[i].openingPoints[k]}d${vkSorted[i].pols.length}` -%>
<%  if(!rootsNames.includes(wName)) { -%>
<%      rootsNames.push(wName); -%>
<%          for(let l = 0; l < vkSorted[i].pols.length; l++) { -%>
    uint16 constant pw<%- wName %>_<%- l %> = <%- memC %>;
<%              memC += 32; -%>
<%          } -%>
<%      } -%>
<%  } -%>
<%  } -%>

    // Lagrange Items
<%  let laNames = [] -%>
<%  for(let i = 0; i < vk.f.length; i++) { -%>
<%      let laName = vk.f[i].openingPoints[0] === 0 ? `${vk.f[i].pols.length}_${vk.f[i].openingPoints.join("")}` : `${vk.f[i].pols.length}_${vk.f[i].openingPoints[0]}d${vk.f[i].pols.length}_${vk.f[i].openingPoints.join("")}` -%>
<%      if(!laNames.includes(laName)) { -%>
<%          laNames.push(laName); -%>
<%      for(let l = 0; l < vk.f[i].pols.length * vk.f[i].openingPoints.length; l++) { -%>
    uint16 constant pLagrange<%- laName %>_<%- l %> = <%- memC %>;
<%          memC += 32; -%>
<%      } -%>
<%      } -%>
<%  } -%>
    

    // Ri
<%  for(let i = 0; i < vk.f.length; ++i) { -%>
    uint16 constant pR<%- i %> = <%- memC %>; // r<%- i %>(y)
<%      memC += 32 -%>
<%  } -%>
   
    uint16 constant pF = <%- memC %>; // [F]_1, 64 bytes
    uint16 constant pE = <%- memC + 64 %>; // [E]_1, 64 bytes
    uint16 constant pJ = <%- memC + 64 * 2 %>; // [J]_1, 64 bytes
<%  memC += 64*3 -%>

<%  for(let i = 1; i < vk.f.length; ++i) { -%>
    uint16 constant pQuotient<%- i %> = <%- memC %>;
<%      memC += 32 -%>
<%  } -%>

    // From this point we write all the variables that must compute the inverse using the Montgomery batch inversion
<% let dens = [] -%>
<% let inversionCounter = 0 -%>
<% let inversionArray = [] -%>
<% for(let i = 1; i < vk.f.length; ++i) { -%>
<%      let dName = vk.f[i].openingPoints[0] === 0 ? `${vk.f[i].pols.length}_${vk.f[i].openingPoints.join("")}` : `${vk.f[i].pols.length}_${vk.f[i].openingPoints[0]}d${vk.f[i].pols.length}_${vk.f[i].openingPoints.join("")}` -%>
<%      if(!dens.includes(dName)) { -%>
<%            dens.push(dName) -%>
    uint16 constant pDenw<%- dName %> = <%- memC %>;
<%      memC += 32 -%>
<% inversionCounter += 1 -%>
<% inversionArray.push(`pDenw${dName}`) -%>
<%      } -%>
<%  } -%>

<% let liNames = [] -%>
<% for(let i = 0; i < vk.f.length; ++i) { -%>
<% for(let k = 0; k < vk.f[i].openingPoints.length; ++k) { -%>
<%      let liName = vk.f[i].openingPoints[k] === 0 ? `${vk.f[i].pols.length}_${vk.f[i].openingPoints.join("")}` : `${vk.f[i].pols.length}_${vk.f[i].openingPoints[k]}d${vk.f[i].pols.length}_${vk.f[i].openingPoints.join("")}` -%>    
<%      if(!liNames.includes(liName)) { -%>  
<%          liNames.push(liName) -%>
<% for(let j = 0; j < vk.f[i].pols.length; ++j) { -%>
    uint16 constant pLiw<%- liName %>Inv_<%- j %> = <%- memC %>;
<% inversionCounter += 1 -%>
<% inversionArray.push(`pLiw${liName}Inv_${j}`) -%>
<%      memC += 32 -%>
<% } -%>
<% } -%>
<% } -%>
<% } -%>

<% if(nonCommittedPols.length > 0) { -%>
<% let commitsCounter = 0; -%>
    // Commits memory data
<%  for(let i = 0; i < nonCommittedPols.length; ++i) { -%>
    uint16 constant pEval_<%- nonCommittedPols[i] %> = <%-commitsCounter %>;
<% commitsCounter += 32 -%>
<%  } -%>
<%  } -%>

<%  let pLastMem = memC -%>
    uint16 constant lastMem = <%- pLastMem %>;

<%  let nBytesCommits = (vk.f.filter(fi => fi.stages.length !== 1 || fi.stages[0].stage !== 0).length + 2) * 2 + orderedEvals.length -%>
<%  let extraParams = "" -%>
<%  if(xiSeed) { -%>
<%    extraParams += ", bytes32 challengeXiSeed" -%>
<%  } -%>
<%  if(nonCommittedPols.length > 0) { -%>
<%    extraParams += `, bytes32[${nonCommittedPols.length}] memory nonCommittedPols` -%>
<%  } -%>

    function verifyCommitments(bytes32[<%- nBytesCommits %>] calldata commits <%- extraParams %>) public view returns (bool) {
        assembly {
            // Computes the inverse of an array of values
            // See https://vitalik.ca/general/2018/07/21/starks_part_3.html in section where explain fields operations
            // To save the inverse to be computed on chain the prover sends the inverse as an evaluation in commits.eval_inv
            function inverseArray(pMem) {

                let pAux := mload(0x40)     // Point to the next free position
                let acc := mload(add(pMem,<%- inversionArray[0] %>))       // Read the first element
                mstore(pAux, acc)

<%  if(extendLoops) { -%>               
<%  for(let i = 1; i < inversionArray.length; ++i) { -%>
                pAux := add(pAux, 32)
                acc := mulmod(acc, mload(add(pMem, <%- inversionArray[i] %>)), q)
                mstore(pAux, acc)

<% } -%>
<% } else { -%>
                let pIn := add(pMem,<%- inversionArray[0] %>)
                for { let j := 1 } lt(j, <%- inversionArray.length %>) { j := add(j, 1)} 
                {
                    pAux := add(pAux, 32)
                    pIn := add(pIn, 32)
                    acc := mulmod(acc, mload(pIn), q)
                    mstore(pAux, acc)
                }
<% } -%>
                let inv := calldataload(pEval_inv)

                // Before using the inverse sent by the prover the verifier checks inv(batch) * batch === 1
                if iszero(eq(1, mulmod(acc, inv, q))) {
                    mstore(0, 0)
                    return(0,0x20)
                }

                acc := inv

<%  if(extendLoops)  { -%>
<%  for(let i = inversionArray.length - 1; i > 0; --i) { -%>
                pAux := sub(pAux, 32)
                inv := mulmod(acc, mload(pAux), q)
                acc := mulmod(acc, mload(add(pMem, <%- inversionArray[i] %>)), q)
                mstore(add(pMem, <%- inversionArray[i] %>), inv)
<% } -%>
<%  } else { -%>
                for { let j := <%- inversionArray.length - 1 %>} gt(j, 0) { j := sub(j, 1)} {
                    pAux := sub(pAux, 32)
                    inv := mulmod(acc, mload(pAux), q)
                    acc := mulmod(acc, mload(pIn), q)
                    mstore(pIn, inv)
                    pIn := sub(pIn, 32)
                }
<% } -%>

                mstore(add(pMem, <%- inversionArray[0] %>), acc)
            }
            
            function checkField(v) {
                if iszero(lt(v, q)) {
                    mstore(0, 0)
                    return(0,0x20)
                }
            }

            function checkPointBelongsToBN128Curve(p) {
                let x := calldataload(p)
                let y := calldataload(add(p, 32))

                // Check that the point is on the curve
                // y^2 = x^3 + 3
                let x3_3 := addmod(mulmod(x, mulmod(x, x, qf), qf), 3, qf)
                let y2 := mulmod(y, y, qf)

                if iszero(eq(x3_3, y2)) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }  
            
            
            // Validate all the evaluations sent by the prover ∈ F
            function checkInput() {        
                // Check commitments fullfill bn128 curve equation Y^2 = X^3 + 3
                checkPointBelongsToBN128Curve(pW)
                checkPointBelongsToBN128Curve(pWp)
<% for(let i = 0; i < vk.f.length; ++i) { -%>
<%      if(vk.f[i].stages.length !== 1 || vk.f[i].stages[0].stage !== 0) { -%>
                checkPointBelongsToBN128Curve(pf<%- vk.f[i].index %>)
<% } -%>
<% } -%>

<% for(let i = 0; i < orderedEvals.length; ++i) { -%>
                checkField(calldataload(pEval_<%- orderedEvals[i] %>))
<% } -%>
            }

            function computePowersXi(pMem, xiSeed) {
<%  const powersXi = degreesXi.map(d => {return {degree: d, power: vk.powerW / d};}).sort((a,b) => a.power - b.power); -%>
                let initValue := 1
<% let wCounter = 0 -%>
<% for (let i = 1; i <= Math.min(vk.powerW, powersXi[powersXi.length - 1].power); ++i) { -%>
                initValue := mulmod(initValue, xiSeed, q)
<%      if(powersXi[wCounter].power === i) { -%>
                mstore(add(pMem, pXiSeed_w<%- powersXi[wCounter++].degree %>), initValue)
<%      } -%>
<% } -%>
            }

            function computeRoots(pMem) {
                let initValue
<%  rootsNames = []; -%>
<%  for(let i = 0; i < vk.f.length; ++i) { -%>
<%          for(let k = 0; k < vk.f[i].openingPoints.length; ++k) { -%>
<%  let wName = vk.f[i].openingPoints[k] === 0 ? vk.f[i].pols.length : `${vk.f[i].pols.length}_${vk.f[i].openingPoints[k]}d${vk.f[i].pols.length}` -%>
<%  if(!rootsNames.includes(wName)) { -%>
<%      rootsNames.push(wName); -%>
<%              let val = vk.f[i].openingPoints[k] === 0 ? `mload(add(pMem, pXiSeed_w${vk.f[i].pols.length}))` : `mulmod(w${vk.f[i].pols.length}_${vk.f[i].openingPoints[k]}d${vk.f[i].pols.length}, mload(add(pMem, pXiSeed_w${vk.f[i].pols.length})),q)` -%>
                initValue := <%- val %>
                mstore( add(pMem, pw<%- wName %>_0),  initValue)
<%              for(let l = 1; l < vk.f[i].pols.length; ++l) { -%>
                mstore( add(pMem, pw<%- wName %>_<%- l %>), mulmod(initValue, w<%- vk.f[i].pols.length %>_<%- l %>, q))
<%              } -%>
<%      } -%>
<%          } -%>
<%      } -%>
            }
<% let challengesFunctionInput = xiSeed ? "pMem, xiSeed" : "pMem" -%>       
            function computeChallenges(<%- challengesFunctionInput %>) {
                let mIn := mload(0x40)
<%  if(!xiSeed) { -%>
                // Compute xiSeed
<%  for(let i = 0; i < vk.f.length; ++i) { -%>
<%  if(vk.f[i].stages.length !== 1 || vk.f[i].stages[0].stage !== 0) { -%>
                mstore(add(mIn,<%- i * 64 %>), calldataload(pf<%- vk.f[i].index %>))
                mstore(add(mIn,<%- i * 64 + 32 %>), calldataload(add(pf<%- vk.f[i].index %>, 32)))
<% } else { -%>
                mstore(add(mIn,<%- i * 64 %>), f<%- vk.f[i].index %>x)
                mstore(add(mIn,<%- i * 64 + 32 %>), f<%- vk.f[i].index %>y)
<%  } -%>
<%  } -%>
                let xiSeed := mod(keccak256(mIn, <%- vk.f.length * 64 %>), q)
                mstore(add(pMem, pXiSeed), xiSeed)
<% } -%>

                // Compute challenge.alpha
                mstore(mIn, xiSeed)
                calldatacopy(add(mIn, 32), pEval_<%- orderedEvals[0] %>, <%- (orderedEvals.length - 1) * 32 %>)

                let alpha := mod(keccak256(mIn, <%- orderedEvals.length * 32 %>), q)
                mstore( add(pMem, pAlpha), alpha)

                mstore(mIn, alpha)
                mstore(add(mIn, 32), calldataload(pW))
                mstore(add(mIn, 64), calldataload(add(pW, 32)))

                // Compute challenge.y
                mstore( add(pMem, pY), mod(keccak256(mIn, 96), q))
            }

<%  const lagrangeSizes = [...new Set(vk.f.map(fi => fi.pols.length * fi.openingPoints.length).filter(s => s > 2))]; -%>
<%  for(let i = 0; i < lagrangeSizes.length; i++) { -%> 
            // This function computes allows as to compute (X-X1)·(X-X2)·...·(X-Xn) used in Lagrange interpolation
            function calcLagrange<%- lagrangeSizes[i] %>Item(idx, X1, X2, pXiMem, pResult1, pResult2) {
                let result1 := 1
                let result2 := 1
                let xi

<% if(!extendLoops) { -%>
                for { let j := 0 } lt(j, <%- lagrangeSizes[i] -%>) { j := add(j, 1) } {
<% } -%>
<% let extendLoopLength = !extendLoops ? 1 : lagrangeSizes[i] -%>
<% for(let l = 0; l < extendLoopLength; ++l) { -%>
<% let j = extendLoops ? l : "j"; -%>
<% let mulj = extendLoops ? l*32 : `mul(j, 32)` -%>
                    if iszero(eq(<%- j %>, idx)) {
                        xi := mload(add(pXiMem, <%- mulj %>))
                        result1 := mulmod(result1, addmod(X1, xi, q), q)
                        result2 := mulmod(result2, addmod(X2, xi, q), q)
                    }

<%  } -%>
<% if(!extendLoops) { -%>
                }
<%  } -%>
                mstore(pResult1, result1)
                mstore(pResult2, result2)
            }   
<%  } -%>

            // Prepare all the denominators that must be inverted, placed them in consecutive memory addresses
            function computeDenValues(pMem) {
                let y := mload(add(pMem, pY))
                let w
<% dens = [] -%>
<% for(let i = 1; i < vk.f.length; ++i) { -%>
<%      let dName = vk.f[i].openingPoints[0] === 0 ? `${vk.f[i].pols.length}_${vk.f[i].openingPoints.join("")}` : `${vk.f[i].pols.length}_${vk.f[i].openingPoints[0]}d${vk.f[i].pols.length}_${vk.f[i].openingPoints.join("")}` -%>
<%      if(!dens.includes(dName)) { -%>
                w := 1
<% for(let k = 0; k < vk.f[i].openingPoints.length; ++k) { -%>
<% for(let j = 0; j < vk.f[i].pols.length; ++j) { -%>
<%              dens.push(dName) -%>
<%  let wName = vk.f[i].openingPoints[k] === 0 ? vk.f[i].pols.length : `${vk.f[i].pols.length}_${vk.f[i].openingPoints[k]}d${vk.f[i].pols.length}` -%>
                w := mulmod(w, addmod(y, mod(sub(q, mload(add(pMem, pw<%- wName %>_<%- j %>))), q), q),q)
<% } -%>
<% } -%>
                mstore(add(pMem, pDenw<%- dName %>), w)
<% } -%>
<% } -%>
            }

            function computeLagrangeItems(pMem) {
                let y := mload(add(pMem, pY))
                let xi
                let pXiMem := mload(0x40)
<%  laNames = [] -%>
<%  for(let i = 0; i < vk.f.length; i++) { -%>
<%      let laName = vk.f[i].openingPoints[0] === 0 ? `${vk.f[i].pols.length}_${vk.f[i].openingPoints.join("")}` : `${vk.f[i].pols.length}_${vk.f[i].openingPoints[0]}d${vk.f[i].pols.length}_${vk.f[i].openingPoints.join("")}` -%>
<%  let wName0 = vk.f[i].openingPoints[0] === 0 ? vk.f[i].pols.length : `${vk.f[i].pols.length}_${vk.f[i].openingPoints[0]}d${vk.f[i].pols.length}` -%>
<%      if(!laNames.includes(laName)) { -%>
<%          laNames.push(laName); -%>
<%          if(vk.f[i].pols.length * vk.f[i].openingPoints.length > 2) { -%>
<%              for(let r = 0; r < vk.f[i].pols.length * vk.f[i].openingPoints.length; ++r) { -%>
                mstore(add(pXiMem, <%- r * 32 %>), mod(sub(q, mload(add(pMem, add(pw<%- wName0 %>_0, <%- r * 32 %>)))), q))
<%              } -%>
<%          } -%> 
<%      let l = 0; -%>
<%      for(let k = 0; k < vk.f[i].openingPoints.length; k++) { -%>
<%      for(let j = 0; j < vk.f[i].pols.length; j++) { -%>
<%  let wName = vk.f[i].openingPoints[k] === 0 ? vk.f[i].pols.length : `${vk.f[i].pols.length}_${vk.f[i].openingPoints[k]}d${vk.f[i].pols.length}` -%>
<%  let liName = vk.f[i].openingPoints[k] === 0 ? `${vk.f[i].pols.length}_${vk.f[i].openingPoints.join("")}` : `${vk.f[i].pols.length}_${vk.f[i].openingPoints[k]}d${vk.f[i].pols.length}_${vk.f[i].openingPoints.join("")}` -%>
<%  if(vk.f[i].pols.length * vk.f[i].openingPoints.length === 1) { -%>
                mstore(add(pMem, pLiw<%- liName %>Inv_<%- j %>), 1)
                mstore(add(pMem, pLagrange<%- laName %>_<%- l %>), 1)
<% } else if(vk.f[i].pols.length * vk.f[i].openingPoints.length === 2) { -%>
                xi := mod(sub(q, mload(add(pMem, add(pw<%- wName0 %>_0, <%- ((l + 1) % 2)*32 %>)))), q)
                mstore(add(pMem, pLiw<%- liName %>Inv_<%- j %>), addmod(mload(add(pMem, add(pw<%- wName0 %>_0, <%- l*32 %>))), xi, q))
                mstore(add(pMem, pLagrange<%- laName %>_<%- l %>), addmod(y, xi, q))
<% } else { -%>
                calcLagrange<%- vk.f[i].pols.length * vk.f[i].openingPoints.length %>Item(<%- l %>, mload(add(pMem,pw<%-wName %>_<%- j %>)), y, pXiMem, add(pMem, pLiw<%- liName %>Inv_<%- j %>), add(pMem, pLagrange<%- laName %>_<%- l %>))
<% } -%>

<%      l++; -%>
<%      } -%>
<%      } -%>
<%      } -%>
<%  } -%>
            }

<%  for(let i = 0; i < vk.f.length; ++i) { -%>
<%      if(vk.f[i].openingPoints.length === 1) { -%>
<%  let wName = vk.f[i].openingPoints[0] === 0 ? vk.f[i].pols.length : `${vk.f[i].pols.length}_${vk.f[i].openingPoints[0]}d${vk.f[i].pols.length}` -%>
<%  let lName = vk.f[i].openingPoints[0] === 0 ? `${vk.f[i].pols.length}_${vk.f[i].openingPoints.join("")}` : `${vk.f[i].pols.length}_${vk.f[i].openingPoints[0]}d${vk.f[i].pols.length}_${vk.f[i].openingPoints.join("")}` -%>
<%  const wPower = vk.f[i].openingPoints[0] === 0 ? '' : vk.f[i].openingPoints[0] === 1 ? 'w' : `w${vk.f[i].openingPoints[0]}` -%>
            function computeR<%- i %>( pMem <%- nonCommittedPols.length > 0 && nonCommittedPols.some(r=> vk.f[i].pols.includes(r)) ? ",pNonCommittedPols" : "" %>) {
                let res
<% if(!extendLoops) { -%>
                for { let i := 0 } lt(i, <%- vk.f[i].pols.length %>) { i := add(i, 1) } {
 <% } -%> 
                    let root
                    let acc
                    let accRoot
                    let lagrange
<% let extendLoopLength = !extendLoops ? 1 : vk.f[i].pols.length -%>
<% for(let l = 0; l < extendLoopLength; ++l) { -%>

<%  const evalPos0 = nonCommittedPols.length === 0 || !nonCommittedPols.includes(vk.f[i].pols[0] + wPower) 
        ? `calldataload(pEval_${vk.f[i].pols[0] + wPower})` 
        : `mload(add(pNonCommittedPols, pEval_${vk.f[i].pols[0] + wPower}))`-%> 
<% if(!extendLoops) { -%>
                    root := mload(add(pMem, add(pw<%- wName %>_0, mul(i,32))))
<% } else { -%>
                    root := mload(add(pMem, pw<%- wName %>_<%- l %>))   
<% } -%>
                    acc := <%- evalPos0 %>
                    accRoot := root
                    
<%  if(extendLoops || (nonCommittedPols.length > 0 && nonCommittedPols.some(r=> vk.f[i].pols.includes(r)))) { -%>
<%  for(let j = 1; j < vk.f[i].pols.length; ++j) { -%> 
<%  const evalPos = nonCommittedPols.length === 0 || !nonCommittedPols.includes(vk.f[i].pols[j] + wPower) 
        ? `calldataload(pEval_${vk.f[i].pols[j] + wPower})` 
        :  `mload(add(pNonCommittedPols, pEval_${vk.f[i].pols[j] + wPower}))`-%>  
                    acc := addmod(acc, mulmod(<%- evalPos %>, accRoot, q), q)
                    accRoot := mulmod(accRoot, root, q)
<% } -%>
<% } else { -%>
                    for { let j := 1 } lt(j, <%- vk.f[i].pols.length %>) { j := add(j, 1)} {
                        acc := addmod(acc, mulmod(<%- `calldataload(add(pEval_${vk.f[i].pols[0] + wPower}, mul(j, 32)))` %>, accRoot, q), q)
                        accRoot := mulmod(accRoot, root, q)
                    }
<% } -%>

<% if(extendLoops) { -%>
                    lagrange := mload(add(pMem, pLagrange<%- lName %>_<%- l %>))
                    lagrange := mulmod(lagrange, mload(add(pMem, pLiw<%- `${wName}_${vk.f[i].openingPoints.join("")}` %>Inv_<%- l %>)), q)
<% } else { -%>
                    lagrange := mload(add(pMem, add(pLagrange<%- lName %>_0, mul(i,32))))
                    lagrange := mulmod(lagrange, mload(add(pMem, add(pLiw<%- `${wName}_${vk.f[i].openingPoints.join("")}` %>Inv_0, mul(i,32)))), q)
<% } -%>
                    res := addmod(res, mulmod(acc, lagrange, q), q)    
<% if(!extendLoops) { -%>
                }
<% } -%>
<% } -%>
                    mstore(add(pMem,pR<%-i %>), res)
            }

<%      } else { -%>
            function computeR<%- i %>( pMem <%- nonCommittedPols.length > 0 && nonCommittedPols.some(r=> vk.f[i].pols.includes(r)) ? ",pNonCommittedPols" : "" %>) {
                let res
<% if(!extendLoops) { -%>
		        for { let i := 0 } lt(i, <%- vk.f[i].pols.length %>) { i := add(i, 1) } {
<% } -%>
                    let root
                    let acc
                    let accRoot
                    let lagrange
<% let extendLoopLength = !extendLoops ? 1 : vk.f[i].pols.length -%>
<% for(let l = 0; l < extendLoopLength; ++l) { -%>

<%  let wName0 = vk.f[i].openingPoints[0] === 0 ? vk.f[i].pols.length : `${vk.f[i].pols.length}_${vk.f[i].openingPoints[0]}d${vk.f[i].pols.length}` -%>
<%  for(let k = 0; k < vk.f[i].openingPoints.length; ++k) { -%>
<%  let wName = vk.f[i].openingPoints[k] === 0 ? vk.f[i].pols.length : `${vk.f[i].pols.length}_${vk.f[i].openingPoints[k]}d${vk.f[i].pols.length}` -%>
<%  let lName = vk.f[i].openingPoints[0] === 0 ? `${vk.f[i].pols.length}_${vk.f[i].openingPoints.join("")}` : `${vk.f[i].pols.length}_${vk.f[i].openingPoints[0]}d${vk.f[i].pols.length}_${vk.f[i].openingPoints.join("")}` -%>
<%  const wPower = vk.f[i].openingPoints[k] === 0 ? '' : vk.f[i].openingPoints[k] === 1 ? 'w' : `w${vk.f[i].openingPoints[k]}` -%>
<%  const evalPos0 = nonCommittedPols.length === 0 || !nonCommittedPols.includes(vk.f[i].pols[0] + wPower) 
        ? `calldataload(pEval_${vk.f[i].pols[0] + wPower})` 
        :  `mload(add(pNonCommittedPols, pEval_${vk.f[i].pols[0] + wPower}))`-%> 
<% if(!extendLoops) { -%>
                    root := mload(add(pMem, add(pw<%- wName %>_0, mul(i,32))))
<% } else { -%>
                    root := mload(add(pMem, pw<%- wName %>_<%- l %>))   
<% } -%>
                    acc := <%- evalPos0 %>
                    accRoot := root

<%  if(extendLoops || (nonCommittedPols.length > 0 && nonCommittedPols.some(r=> vk.f[i].pols.includes(r)))) { -%>                   
<%  for(let j = 1; j < vk.f[i].pols.length; ++j) { -%>
<%  const evalPos = nonCommittedPols.length === 0 || !nonCommittedPols.includes(vk.f[i].pols[j] + wPower) 
        ? `calldataload(pEval_${vk.f[i].pols[j] + wPower})` 
        :  `mload(add(pNonCommittedPols, pEval_${vk.f[i].pols[j] + wPower}))`-%>
                    acc := addmod(acc, mulmod(<%- evalPos %>, accRoot, q), q)
                    accRoot := mulmod(accRoot, root, q)
<% } -%>
<% } else { -%>
                    for { let j := 1 } lt(j, <%- vk.f[i].pols.length %>) { j := add(j, 1)} {
                        acc := addmod(acc, mulmod(<%- `calldataload(add(pEval_${vk.f[i].pols[0] + wPower}, mul(j, 32)))` %>, accRoot, q), q)
                        accRoot := mulmod(accRoot, root, q)
                    }
<% } -%>

<% if(extendLoops) { -%>
                    lagrange := mload(add(pMem, pLagrange<%- lName %>_<%- k === 0 ? l : l + k*vk.f[i].pols.length %>))
                    lagrange := mulmod(lagrange, mload(add(pMem, pLiw<%- `${wName}_${vk.f[i].openingPoints.join("")}` %>Inv_<%- l %>)), q)
<% } else { -%>
                    lagrange := mload(add(pMem, add(pLagrange<%- lName %>_0, mul(<%- k === 0 ? "i" : `add(i, ${k*vk.f[i].pols.length})` %>,32))))
                    lagrange := mulmod(lagrange, mload(add(pMem, add(pLiw<%- `${wName}_${vk.f[i].openingPoints.join("")}` %>Inv_0, mul(i, 32)))), q)
<% } -%>
                    res := addmod(res, mulmod(acc, lagrange, q), q)
<% } -%>
<% if(!extendLoops) { -%>
                }
<% } -%>
<% } -%>
                mstore(add(pMem,pR<%-i %>), res)
            }
<%      } -%>
<%  } -%>
            
            // G1 function to accumulate a G1 value to an address
            function g1_acc(pR, pP) {
                let mIn := mload(0x40)
                mstore(mIn, mload(pR))
                mstore(add(mIn,32), mload(add(pR, 32)))
                mstore(add(mIn,64), mload(pP))
                mstore(add(mIn,96), mload(add(pP, 32)))

                let success := staticcall(gas(), 6, mIn, 128, pR, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0,0x20)
                }
            }

            // G1 function to multiply a G1 value to value in an address
            function g1_mulAcc(pR, px, py, s) {
                let success
                let mIn := mload(0x40)
                mstore(mIn, px)
                mstore(add(mIn,32), py)
                mstore(add(mIn,64), s)

                success := staticcall(gas(), 7, mIn, 96, mIn, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0,0x20)
                }

                mstore(add(mIn,64), mload(pR))
                mstore(add(mIn,96), mload(add(pR, 32)))

                success := staticcall(gas(), 6, mIn, 128, pR, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0,0x20)
                }
            }

            function computeFEJ(pMem) {
                // Prepare shared numerator between F, E and J to reuse it
                let y := mload(add(pMem, pY))
                let numerator := 1
<% for(let i = 0; i < vk.f[0].pols.length * vk.f[0].openingPoints.length; ++i) { -%>
                numerator := mulmod(numerator, addmod(y, mod(sub(q, mload(add(pMem, pw<%- vk.f[0].pols.length %>_<%- i %>))), q), q), q)
<% } -%>
                
                // Prepare shared quotient between F and E to reuse it
                let alpha := mload(add(pMem, pAlpha))
                let accAlpha := 1
<% for(let i = 1; i < vk.f.length; ++i) { -%>
                accAlpha := mulmod(accAlpha, alpha, q)
<%  let wName = vk.f[i].openingPoints[0] === 0 ? vk.f[i].pols.length : `${vk.f[i].pols.length}_${vk.f[i].openingPoints[0]}d${vk.f[i].pols.length}` -%>
                mstore(add(pMem, pQuotient<%- i %>), mulmod(accAlpha, mulmod(numerator, mload(add(pMem, pDenw<%- wName %>_<%- vk.f[i].openingPoints.join("") %>)), q), q))
<% } -%>

                
                // Compute full batched polynomial commitment [F]_1
<%  if(vk.f[0].stages.length !== 1 || vk.f[0].stages[0].stage !== 0) { -%>
                mstore(add(pMem, pF), calldataload(pf0))
                mstore(add(pMem, add(pF, 32)), calldataload(add(pf0, 32)))
<% } else { -%>
                mstore(add(pMem, pF), f0x)
                mstore(add(pMem, add(pF, 32)), f0y)
<% } -%>
<% for(let i = 1; i < vk.f.length; ++i) { -%>
<%  if(vk.f[i].stages.length !== 1 || vk.f[i].stages[0].stage !== 0) { -%>
                g1_mulAcc(add(pMem, pF), calldataload(pf<%- i %>), calldataload(add(pf<%- i %>, 32)), mload(add(pMem,pQuotient<%- i %>)))
<% } else { -%>
                g1_mulAcc(add(pMem, pF), f<%- i %>x, f<%- i %>y, mload(add(pMem,pQuotient<%- i %>)))
<% } -%>
<% } -%>

                // Compute group-encoded batch evaluation [E]_1

                let accR := mload(add(pMem, pR0))
<% for(let i = 1; i < vk.f.length; ++i) { -%>
                accR := addmod(accR, mulmod(mload(add(pMem,pQuotient<%- i %>)), mload(add(pMem, pR<%- i %>)),q) ,q)
<% } -%>
                g1_mulAcc(add(pMem, pE), G1x, G1y, accR)

                // Compute the full difference [J]_1
                g1_mulAcc(add(pMem, pJ), calldataload(pW), calldataload(add(pW, 32)), numerator)
            }
 
            // Validate all evaluations with a pairing checking that e([F]_1 - [E]_1 - [J]_1 + y[Wp]_1, [1]_2) == e([Wp]_1, [x]_2)
            function checkPairing(pMem) -> isOk {
                let mIn := mload(0x40)

                // First pairing value
                // Compute -E
                mstore(add(add(pMem, pE), 32), mod(sub(qf, mload(add(add(pMem, pE), 32))), qf))
                // Compute -J
                mstore(add(add(pMem, pJ), 32), mod(sub(qf, mload(add(add(pMem, pJ), 32))), qf))
                // F = F - E - J + y·Wp
                g1_acc(add(pMem, pF), add(pMem, pE))
                g1_acc(add(pMem, pF), add(pMem, pJ))
                g1_mulAcc(add(pMem, pF), calldataload(pWp), calldataload(add(pWp, 32)), mload(add(pMem, pY)))

                mstore(mIn, mload(add(pMem, pF)))
                mstore(add(mIn, 32), mload(add(add(pMem, pF), 32)))

                // Second pairing value
                mstore(add(mIn, 64), G2x2)
                mstore(add(mIn, 96), G2x1)
                mstore(add(mIn, 128), G2y2)
                mstore(add(mIn, 160), G2y1)

                // Third pairing value
                // Compute -Wp
                mstore(add(mIn, 192), calldataload(pWp))
                let s := calldataload(add(pWp, 32))
                s := mod(sub(qf, s), qf)
                mstore(add(mIn, 224), s)

                // Fourth pairing value
                mstore(add(mIn, 256), X2x2)
                mstore(add(mIn, 288), X2x1)
                mstore(add(mIn, 320), X2y2)
                mstore(add(mIn, 352), X2y1)

                let success := staticcall(gas(), 8, mIn, 384, mIn, 0x20)

                isOk := and(success, mload(mIn))
            }

            let pMem := mload(0x40)
            mstore(0x40, add(pMem, lastMem))

            // Validate that all evaluations ∈ F
            checkInput()

<% let xiSeedValue = xiSeed ? "challengeXiSeed" : "mload(add(pMem, pXiSeed))" -%>
<% let challengesInput = xiSeed ? "pMem, challengeXiSeed" : "pMem" -%>       
            // Compute the challenges alpha and y ∈ F
            computeChallenges(<%- challengesInput %>)

            // Compute powers of xi seed
            computePowersXi(pMem, <%- xiSeedValue %>)
            
            // Compute roots
            computeRoots(pMem)

            // To divide prime fields the Extended Euclidean Algorithm for computing modular inverses is needed.
            // The Montgomery batch inversion algorithm allow us to compute n inverses reducing to a single one inversion.
            // More info: https://vitalik.ca/general/2018/07/21/starks_part_3.html
            // To avoid this single inverse computation on-chain, it has been computed in proving time and send it to the verifier.
            // Therefore, the verifier:
            //      1) Prepare all the denominators to inverse
            //      2) Check the inverse sent by the prover it is what it should be
            //      3) Compute the others inverses using the Montgomery Batched Algorithm using the inverse sent to avoid the inversion operation it does.
            computeDenValues(pMem)

            // Compute Lagrange Items to avoid calculating it more than once
            computeLagrangeItems(pMem)

            // Execute Montgomery batched inversions of the previous prepared values
            inverseArray(pMem)

<% for(let i = 0; i < vk.f.length; ++i) { -%>
<% if(nonCommittedPols.length > 0 && nonCommittedPols.some(r=> vk.f[i].pols.includes(r))) { -%>
            computeR<%- i %>(pMem, nonCommittedPols)
<% } else { -%>
            computeR<%- i %>(pMem)
<% } -%>
<% } -%>

            // Compute full batched polynomial commitment [F]_1, group-encoded batch evaluation [E]_1 and the full difference [J]_1
            computeFEJ(pMem)

            // Validate all evaluations
            let isValid := checkPairing(pMem)

            mstore(0x40, sub(pMem, lastMem))
            mstore(0, isValid)
            return(0,0x20)
        }
    }
}
